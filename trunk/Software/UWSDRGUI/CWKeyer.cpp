/*
 *   Copyright (C) 2006-2007 by Jonathan Naylor G4KLX
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "CWKeyer.h"

#include "UWSDRApp.h"

const float RC_LEN   = 5.0F;	// The length of the raised cosine in ms

const int DOT_LEN    = 1;
const int DASH_LEN   = 3;
const int SYMBOL_GAP = 1;
const int LETTER_GAP = 3;
const int WORD_GAP   = 7;


CCWKeyer::CCWKeyer() :
CThreadReader(),
m_sampleRate(0.0F),
m_blockSize(0U),
m_callback(NULL),
m_id(0),
m_bits(NULL),
m_bitsLen(0U),
m_bitsIndex(0U),
m_key(false),
m_lastKey(false),
m_buffer(NULL),
m_defLen(0U),
m_cosDelta(0.0F),
m_sinDelta(0.0F),
m_cosValue(1.0F),
m_sinValue(0.0F)
{
}

CCWKeyer::~CCWKeyer()
{
	delete[] m_bits;
	delete[] m_buffer;
}

bool CCWKeyer::open(float sampleRate, unsigned int blockSize)
{
	wxASSERT(sampleRate > 0.0F);

	m_sampleRate = sampleRate;
	m_blockSize  = blockSize;

	// Calculate the length of the raised cosine shaping section
	m_defLen = (unsigned int)(RC_LEN * m_sampleRate / 1000.0F + 0.5F);

	float delta = CW_OFFSET / m_sampleRate * 2.0 * M_PI;

	m_cosDelta = ::cos(delta);
	m_sinDelta = ::sin(delta);

	m_buffer = new float[m_blockSize * 2U];

	return CThreadReader::open(sampleRate, blockSize);
}

void CCWKeyer::abort()
{
	end();
}

/*
 * This is called from the "software interrupt" generated by the sound card carrying
 * the microphone audio. It is called once per BLOCK_SIZE samples.
 */
bool CCWKeyer::create()
{
	// Key pressed when transmitting from the CW keyboard, abort
	if (m_key && m_bitsLen > 0U) {
		end();
		return true;
	}

	// Sending a message from the keyboard
	if (m_bitsLen > 0U) {
		// End of the message ?
		if (m_bitsIndex == m_bitsLen) {
			end();
			return true;
		}

		// Send the next unit, from the bit array
		bool key = m_bits[m_bitsIndex++];
		processKey(key);
		return true;
	}

	// Use the status of the real key
	processKey(m_key);
	return true;
}

void CCWKeyer::setCallback(IDataCallback* callback, int id)
{
	m_callback = callback;
	m_id       = id;
}

/*
 * Set the speed in WPM and generate a bit map of the individual blocks with
 * carrier (or not) entries.
 */
void CCWKeyer::send(unsigned int speed, const wxString& text)
{
	wxASSERT(speed >= 5 && speed <= 30);

	unsigned int textLen = text.Length();

	if (textLen == 0U)
		return;

	unsigned int mult = speedToUnits(speed);

	// Quick and dirty maximum length calculation
	unsigned int bitsLen = textLen * 4U * mult;

	m_bits = new bool[bitsLen];

	bitsLen = 0U;

	unsigned int j;
	for (unsigned int i = 0U; i < textLen; i++) {
		wxChar c = text.GetChar(i);

		switch (c) {
			case wxT('.'):
				for (j = 0U; j < 1U * mult; j++)
					m_bits[bitsLen++] = true;
				break;

			case wxT('-'):
				for (j = 0U; j < 3U * mult; j++)
					m_bits[bitsLen++] = true;
				break;

			case wxT(' '):
				for (j = 0U; j < 1U * mult; j++)
					m_bits[bitsLen++] = false;
				break;
		}

		for (j = 0U; j < 1U * mult; j++)
			m_bits[bitsLen++] = false;
	}

	m_bitsLen   = bitsLen;
	m_bitsIndex = 0U;
}

/*
 * Calculate the length of a dot in numbers of blocks, the speed in words per minute.
 * At 12.5 WPM a dot is 1/10 of a second.
 */
unsigned int CCWKeyer::speedToUnits(unsigned int speed)
{
	float sysUnitsPerSec = m_sampleRate / float(m_blockSize);

	float unitsPerSec = 10.0F * float(speed) / 12.5F;

	unsigned int mult = (unsigned int)(sysUnitsPerSec / unitsPerSec + 0.5F);

	if (mult == 0U)
		return 1U;

	return mult;
}

void CCWKeyer::end()
{
	m_bitsLen   = 0U;
	m_bitsIndex = 0U;

	delete[] m_bits;
	m_bits = NULL;

	::wxGetApp().sendCW(CW_END, wxEmptyString);
}

bool CCWKeyer::isActive() const
{
	return true;
}

void CCWKeyer::key(bool keyDown)
{
	m_key = keyDown;
}

void CCWKeyer::processKey(bool key)
{
	wxASSERT(m_callback != NULL);

	// Generate silence
	if (!key && !m_lastKey) {
		::memset(m_buffer, 0x00, m_blockSize * 2 * sizeof(float));
		m_callback->callback(m_buffer, m_blockSize, m_id);
		return;
	}

	// Reset the phase if beginning a symbol
	if (key && !m_lastKey) {
		m_cosValue = 1.0F;
		m_sinValue = 0.0F;
	}

	// Generate a continuous tone, phase contiguous with the previous one
	for (unsigned int i = 0; i < m_blockSize; i++) {
		float tmpValue = m_cosValue * m_cosDelta - m_sinValue * m_sinDelta;
		m_sinValue = m_cosValue * m_sinDelta + m_sinValue * m_cosDelta;
		m_cosValue = tmpValue;

		m_buffer[i * 2U + 0U] = m_sinValue;
		m_buffer[i * 2U + 1U] = m_sinValue;
	}

	// Continuous tone
	if (key && m_lastKey) {
		m_callback->callback(m_buffer, m_blockSize, m_id);
		return;
	}

	// Start of a tone, shape the beginning
	if (key && !m_lastKey) {
		for (unsigned int i = 0; i < m_defLen; i++) {
			float ampl = 0.5F * (1.0F - ::cos(M_PI * (float(i) / float(m_defLen))));

			m_buffer[i * 2U + 0U] *= ampl;
			m_buffer[i * 2U + 1U] *= ampl;
		}

		m_callback->callback(m_buffer, m_blockSize, m_id);
		m_lastKey = key;
		return;
	}

	// The end of a tone, so we transmit just enough to shape it, and then silence
	for (unsigned int j = 0; j < m_defLen; j++) {
		float ampl = 0.5F * (1.0F - ::cos(M_PI + M_PI * (float(j) / float(m_defLen))));

		m_buffer[j * 2U + 0U] *= ampl;
		m_buffer[j * 2U + 1U] *= ampl;
	}

	if (m_defLen < m_blockSize)
		::memset(m_buffer + m_defLen * 2U, 0x00, (m_blockSize - m_defLen) * 2 * sizeof(float));

	m_callback->callback(m_buffer, m_blockSize, m_id);
	m_lastKey = key;
}
