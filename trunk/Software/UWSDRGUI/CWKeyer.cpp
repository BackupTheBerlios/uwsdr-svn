/*
 *   Copyright (C) 2006-2007 by Jonathan Naylor G4KLX
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "CWKeyer.h"

#include "UWSDRApp.h"

const int DEF_SPEED  = 14;

const int DOT_LEN    = 1;
const int DASH_LEN   = 3;
const int SYMBOL_GAP = 1;
const int LETTER_GAP = 3;
const int WORD_GAP   = 7;


CCWKeyer::CCWKeyer() :
CThreadReader(),
m_sampleRate(0.0F),
m_blockSize(0U),
m_callback(NULL),
m_id(0),
m_dotLen(0U),
m_text(),
m_status(CW_STOPPED),
m_stop(false),
m_keyDown(false),
m_lastKeyDown(false),
m_buffer(NULL),
m_dotBuffer(NULL),
m_dashBuffer(NULL),
m_silBuffer(NULL),
m_cwBuffer(NULL),
m_defLen(0U),
m_cosDelta(0.0F),
m_sinDelta(0.0F),
m_cosValue(1.0F),
m_sinValue(0.0F)
{
}

CCWKeyer::~CCWKeyer()
{
	delete[] m_buffer;
	delete[] m_dotBuffer;
	delete[] m_dashBuffer;
	delete[] m_silBuffer;
	delete   m_cwBuffer;
}

bool CCWKeyer::open(float sampleRate, unsigned int blockSize)
{
	wxASSERT(sampleRate > 0.0F);

	m_sampleRate = sampleRate;
	m_blockSize  = blockSize;

	// Calculate the default speed for hand keying
	unsigned int dotLen = calcDotLength(DEF_SPEED);
	m_defLen = (dotLen * DOT_LEN) / 10;

	float delta = CW_OFFSET / m_sampleRate * 2.0 * M_PI;

	m_cosDelta = ::cos(delta);
	m_sinDelta = ::sin(delta);

	m_buffer = new float[m_blockSize * 2];

	// Allocate buffers based on the slowest speed that we handle
	dotLen = calcDotLength(5);

	m_dotBuffer   = new float[dotLen * DOT_LEN];
	m_dashBuffer  = new float[dotLen * DASH_LEN];
	m_silBuffer   = new float[dotLen * DOT_LEN];

	::memset(m_silBuffer, 0x00, dotLen * DOT_LEN * sizeof(float));

	m_cwBuffer = new CRingBuffer(dotLen * 10, 1);

	return CThreadReader::open(sampleRate, blockSize);
}

void CCWKeyer::close()
{
	m_status = CW_STOPPED;

	CThreadReader::close();
}

void CCWKeyer::abort()
{
	if (m_status != CW_STOPPED)
		m_stop = true;
}

/*
 * This is called from the "software interrupt" generated by the sound card carrying
 * the microphone audio. It is called once per BLOCK_SIZE samples.
 */
bool CCWKeyer::create()
{
	wxASSERT(m_callback != NULL);

	if (m_status != CW_RUNNING) {
		processKey();
		return true;
	}

	// Aborted or end of transmission
	if (m_stop || (m_cwBuffer->dataSpace() == 0 && m_text.length() == 0)) {
		::memset(m_buffer, 0x00, m_blockSize * 2 * sizeof(float));
		m_callback->callback(m_buffer, m_blockSize, m_id);

		m_stop   = false;
		m_status = CW_STOPPED;

		::wxGetApp().sendCW(0, wxEmptyString);

		return true;
	}

	if (m_cwBuffer->dataSpace() < m_blockSize)
		fillBuffer();

	for (unsigned int i = 0; i < m_blockSize; i++) {
		float f;
		unsigned int n = m_cwBuffer->getData(&f, 1);

		// No more data, so fill with silence
		if (n == 0)
			f = 0.0F;

		m_buffer[i * 2 + 0] = f;
		m_buffer[i * 2 + 1] = f;
	}

	m_callback->callback(m_buffer, m_blockSize, m_id);

	return true;
}

void CCWKeyer::setCallback(IDataCallback* callback, int id)
{
	m_callback = callback;
	m_id       = id;
}

/*
 * Set the speed in WPM and generate the dot length in samples as well as the
 * dot and dash samples.
 */
void CCWKeyer::send(unsigned int speed, const wxString& text)
{
	wxASSERT(speed >= 5 && speed <= 30);

	m_dotLen = calcDotLength(speed);

	createSymbol(m_dotBuffer,  m_dotLen * DOT_LEN);
	createSymbol(m_dashBuffer, m_dotLen * DASH_LEN);

	if (text.length() == 0)
		return;

	m_cwBuffer->clear();

	m_status = CW_RUNNING;
	m_stop   = false;
	m_text   = text;
}

/*
 * Create a sine wave of the correct tone of the desired length and shape it with
 * a raised cosine to minimise key clicks.
 */
void CCWKeyer::createSymbol(float* buffer, unsigned int len)
{
	wxASSERT(buffer != NULL);

	float cosVal = 1.0F;
	float sinVal = 0.0F;

	for (unsigned int i = 0; i < len; i++) {
		float tmpVal = cosVal * m_cosDelta - sinVal * m_sinDelta;
		sinVal = cosVal * m_sinDelta + sinVal * m_cosDelta;
		cosVal = tmpVal;

		buffer[i] = sinVal;
	}

	unsigned int l = (m_dotLen * DOT_LEN) / 10;

	// Now shape it
	for (unsigned int j = 0; j < l; j++) {
		float ampl = 0.5F * (1.0F + ::cos(M_PI + M_PI * (float(j) / float(l))));

		buffer[j]       *= ampl;
		buffer[len - j] *= ampl;
	}
}

void CCWKeyer::fillBuffer()
{
	while (m_cwBuffer->freeSpace() > (m_dotLen * DASH_LEN * 3) && m_text.length() > 0) {
		wxChar c = m_text.GetChar(0);

		switch (c) {
			case wxT('.'):
				m_cwBuffer->addData(m_dotBuffer, m_dotLen * DOT_LEN);
				m_cwBuffer->addData(m_silBuffer, m_dotLen * DOT_LEN);
				break;

			case wxT('-'):
				m_cwBuffer->addData(m_dashBuffer, m_dotLen * DASH_LEN);
				m_cwBuffer->addData(m_silBuffer,  m_dotLen * DOT_LEN);
				break;

			case wxT(' '):
				m_cwBuffer->addData(m_silBuffer, m_dotLen * DOT_LEN);
				m_cwBuffer->addData(m_silBuffer, m_dotLen * DOT_LEN);
				m_cwBuffer->addData(m_silBuffer, m_dotLen * DOT_LEN);
				break;
		}

		m_text = m_text.Right(m_text.length() - 1);
	}
}

/*
 * Calculate the length of a dot in samples from the speed in words per minute.
 * At 12 WPM a dot is 1/10 of a second.
 */
unsigned int CCWKeyer::calcDotLength(int speed)
{
	return (unsigned int)(m_sampleRate * 1.2F / float(speed) + 0.5F);
}

bool CCWKeyer::isActive() const
{
	return m_status == CW_RUNNING;
}

void CCWKeyer::key(bool keyDown)
{
	m_keyDown = keyDown;
}

void CCWKeyer::processKey()
{
	// Generate silence
	if (!m_keyDown && !m_lastKeyDown) {
		::memset(m_buffer, 0x00, m_blockSize * 2 * sizeof(float));
		m_callback->callback(m_buffer, m_blockSize, m_id);
		return;
	}

	// Reset the phase if beginning a symbol
	if (m_keyDown && !m_lastKeyDown) {
		m_cosValue = 1.0F;
		m_sinValue = 0.0F;
	}

	// Generate a continuous tone, phase contiguous with the previous one
	for (unsigned int i = 0; i < m_blockSize; i++) {
		float tmpValue = m_cosValue * m_cosDelta - m_sinValue * m_sinDelta;
		m_sinValue = m_cosValue * m_sinDelta + m_sinValue * m_cosDelta;
		m_cosValue = tmpValue;

		m_buffer[i * 2 + 0] = m_sinValue;
		m_buffer[i * 2 + 1] = m_sinValue;
	}

	// Continuous tone
	if (m_keyDown && m_lastKeyDown) {
		m_callback->callback(m_buffer, m_blockSize, m_id);
		return;
	}

	// Start of a tone, shape the beginning
	if (m_keyDown && !m_lastKeyDown) {
		for (unsigned int i = 0; i < m_defLen; i++) {
			float ampl = 0.5F * (1.0F + ::cos(M_PI + M_PI * (float(i) / float(m_defLen))));

			m_buffer[i * 2 + 0] *= ampl;
			m_buffer[i * 2 + 1] *= ampl;
		}

		m_callback->callback(m_buffer, m_blockSize, m_id);
		m_lastKeyDown = m_keyDown;
		return;
	}

	// The end of a tone, so we transmit just enough to shape it, and then silence
	for (unsigned int j = 0; j < m_defLen; j++) {
		float ampl = 0.5F * (1.0F + ::cos(M_PI * (float(j) / float(m_defLen))));

		m_buffer[j * 2 + 0] *= ampl;
		m_buffer[j * 2 + 1] *= ampl;
	}

	if (m_defLen < m_blockSize)
		::memset(m_buffer + m_defLen * 2, 0x00, (m_blockSize - m_defLen) * 2 * sizeof(float));

	m_callback->callback(m_buffer, m_blockSize, m_id);
	m_lastKeyDown = m_keyDown;
}
